{"meta":{"title":"No one","subtitle":"Valar Morghulis Valar Dohaeris","description":null,"author":"TwoDog Targaryen","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-03-20T01:45:14.582Z","updated":"2019-03-20T01:45:14.522Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-19T12:04:12.000Z","updated":"2019-03-20T01:10:39.840Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"从pc端到移动端","slug":"从pc端到移动端","date":"2019-04-21T03:27:34.000Z","updated":"2019-04-21T03:54:16.553Z","comments":true,"path":"2019/04/21/从pc端到移动端/","link":"","permalink":"http://yoursite.com/2019/04/21/从pc端到移动端/","excerpt":"","text":"##如何把已有的PC端网站转换为移动端： 可以在mate标签下面加一行 1&lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no\" /&gt; 需要调整的UI比较多，但是后台数据不用调整太多。 ##当然也可以用两套网站，但是首先要判断用户是在用什么登陆，这里我们需要了解Navigator对象 这个对象下的userAgent是一个可读的字符串，声明了浏览器用于HTTP请求的用户处理头，这样我们就可以navigator.useragent来看目前访问网站的是什么设备，比如说我在mac那么就是 1Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36 所以就可以用下面的代码来进行判断目前访问网站的是什么设备 12345if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) &#123; window.location.href = \"移动端url\";&#125; else &#123; window.location.href = \"pc端url\";&#125;","categories":[],"tags":[]},{"title":"Vue中template解析","slug":"Vue中template解析","date":"2019-04-15T12:22:54.000Z","updated":"2019-04-15T12:37:14.455Z","comments":true,"path":"2019/04/15/Vue中template解析/","link":"","permalink":"http://yoursite.com/2019/04/15/Vue中template解析/","excerpt":"","text":"Vue中的Complie会把template模板解析成AST语法树，AST语法树再通过generate得到render函数，render函数的返回值就是VNode，VNode就是我们常说的虚拟Dom，最后在虚拟Dom渲染到真实Dom上。","categories":[],"tags":[]},{"title":"前端性能优化","slug":"前端性能优化","date":"2019-04-08T00:52:28.000Z","updated":"2019-04-15T12:13:56.604Z","comments":true,"path":"2019/04/08/前端性能优化/","link":"","permalink":"http://yoursite.com/2019/04/08/前端性能优化/","excerpt":"","text":"##1. 减少HTTP请求 ##1) 合并文件 把所有的脚本放在一个文件中请求，也可以合并所有的CSS，如果每个页面的脚本和样式不一样的话，就会是一项比较麻烦的工作 2) CSS Sprites 这是减少图片请求数量的方式(首选)，把所有的背景图片都整合到一张图片中，然后用CSS的background-image和background-position属性来定位要显示的部分 3) 图像映射 可以把多张图片合并成单张图片，但是总大小是一样的，减少了HTTP请求数量 4) 行内图片 用data: URL模式来把图片嵌入页面，这样会增加HTML文件的大小，把行内图片放在缓存的样式表中可以成功避免HTML文件的大小，但是目前的主流浏览器并不能很好的支持行内图片 ##2. 避免重定向 ##重定向会严重的影响用户体验，在用户和html之间插入重定向会验车页面上所有东西的加载，页面没办法渲染，组件没有办法下载，知道html被送到浏览器 如果说页面上跳转到http://abc.com/user会返回一个http://abc.com/user/的301响应，可以使用Apache中可以用Alias，mod_rewrite或者DirectorySlash指令来取消不必要的重定向 ##3. 延迟加载组件 ##分析页面看看那些内容是一进来必须要加载的，那些内容可以等一会在加载。使用onload事件来区别。 在客户端支持js的时候可以提高用户体验，但是必须确保页面在不支持js的时候也能正常工作，在确定页面运行正常之后延迟加载脚本去增强用户体验以及支持一些拖放和动画等，也可以使用‘渐进增强’ ##4. 预加载组件 ##预加载和上面的延迟加载看起来是相反的，但是它和延迟加载有不一样的目的，预加载组件可以充分利用浏览器空余时间去请求一些将来会用到的组件(图片、样式表、脚本等)，预加载分为下面这几种 1) 无条件预加载 尽快开始加载，获取一些额外的组件 2) 条件性预加载 根据用户已经完成的操作猜测用户将要跳转到哪个页面并据此预加载 3) 在退出新设计(页面等)的时候用户可能会有‘这些新东西不错，但是比之前的更慢了’这种想法，面对这种想法可以通过在旧的网站的浏览器空闲时间来加载新设计(页面)的脚本 ##5. 减少DOM元素的数量以及操作 ##更多的DOM元素意味着这个网站更大，也就是意味这需要下载更多的字节，一个网站上500个DOM元素和5000个DOM元素在加载的时候是有区别的。 操作DOM有可能造成页面的重绘以及重构，会对页面的性能造成损耗，所以要尽可能的避免 ##6. 杜绝404错误 ##有的网站中会有比较有帮助的404(你的意思是这样吗？)，但是会浪费服务器资源，最不应该浪费的是链接到外部的脚本等，这种请求将阻塞并行下载 ##7. 避免使用css的表达式 ##css的表达式非常方便，从IE5开始支持，但是到IE8就不推荐使用了 ##8. 外部文件 ##可以把js以及css放在外面，因为这样浏览器可以进行缓存，如果写在页面中或者直接写在行内这样每次请求这个html的时候都会重新下载，这样会减少html文件大小，但是会增加http请求数量，可是第一次请求之后js和css就会被缓存在浏览器中，这样既减少了http请求数量也减少了html文件的大小 ##9. 避免img的src的属性为空值 ##如果为空值的话浏览器就会向服务器发一次请求，要避免这种请求","categories":[],"tags":[]},{"title":"前后端的连接步骤","slug":"前后端的连接步骤","date":"2019-04-05T07:28:11.000Z","updated":"2019-04-05T07:50:08.096Z","comments":true,"path":"2019/04/05/前后端的连接步骤/","link":"","permalink":"http://yoursite.com/2019/04/05/前后端的连接步骤/","excerpt":"","text":"前后端的连接步骤又叫做’三次握手四次挥手’，下面咱们先来说说是怎么’握手’(连接)的 客户端：发送请求(syn包)进入SYN_SEND状态 服务端：收到syn包之后确认客户端的syn，服务器进入SYN_RECV，之后发送一个syn，就是syn+ack 客户端：收到服务端发送过来的SYN包之后，发送一个确认包ACK，发送之后进入ESTABLISHED状态 完成之后开始传输数据 如果看不懂上面的可以看看下面的 客户端：你好 服务端：你好，很高兴认识你 客户端：你好，我也很高兴认识你 之后就开始聊天了 好了，现在两个人聊的差不多，要回家了，现在应该怎么说呢？来看看’四次挥手’ 客户端：发送一个FIN 服务端：收到FIN，发挥ACK，确定序号为收到的序号+1 服务端：服务端关闭连接，发送一个FIN 客户端：收到FIN之后，发送一个ACK，序号为确定序号+1 完成之后双方就关闭了 如果看不懂还是看下面 客户端：天不早了，我要回家了 服务端：天确实不早了 服务端：你回去吧，我也回了 客户端，好勒~","categories":[],"tags":[]},{"title":"git命令和用法","slug":"git命令和用法","date":"2019-03-25T04:02:03.000Z","updated":"2019-03-27T12:31:08.898Z","comments":true,"path":"2019/03/25/git命令和用法/","link":"","permalink":"http://yoursite.com/2019/03/25/git命令和用法/","excerpt":"","text":"一、安装git 在Windows系统上使用git，可以从git官网直接下载安装程序，然后按默认选项安装即可。安装完成后，在桌面右击，会有Git Bash，就说明安装成功了。 安装完成后，需要设置用户名和邮箱 12$ git config --global user.name 'your name'$ git config --global user.email 'your email' 二、创建版本库 版本库又叫做仓库或者repository，可以理解为一个目录，里面所有的东西都被git管理起来了，方便查看和还原以前的内容 首先先建立一个新目录，通过cmd进入终端，输入git init，将这个文件夹变成git可以管理的仓库 1$ git init 做完这些你就会发现，目录里多了一个.git文件，这样就创建成功了 三、把文件添加到版本库 首先建立一个index.html(什么名字都可以)，这个文件的位置必须在.git这个文件夹的根目录下 第一步：用命令 git add 把文件添加到仓库 1$ git add index.html 如果没有任何消息，就是添加成功了 第二步：用命令 git commit 把文件提交到仓库 1234$ git commit -m '这是我的第一天学习git'[master (root-commit) 5fb4e8a] 这是我的第一天学习git 1 file changed, 10 insertions(+) create mode 100644 index.html 在这句话后面还可以跟上你这次提交的说明，可以写中文，在完成之后，可以看到有1个文件被改动，插入了10行内容。 另外分两次使用可以使用 git add 多次添加文件，使用 git commit 一次性提交 四、版本查看与回退 可以使用 vim 文件名 进入文件的命令模式，之后输入字母i可以进入编辑模式。编辑完成之后按下ESC键退出编辑模式，输入zz或者:wq保存并退出vim。如果只想保存文件，则输入:w，回车后底行会提示写入操作结果，并保持停留在命令模式。 在命令模式下输入:q!退出vim并放弃修改。放弃修改并且不退出vim模式请输入:e!，将回退到最近一次修改之后的命令模式 修改之后输入 git status 命令查看结果，git status 可以让我们实时掌握自己git仓库的状态 123456789$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\") 这里的输出告诉我们，虽然index.html被修改了，但是修改之后的内容还没有进行提交 现在可以输入 git diff 去查看我们到底该了那些内容 1234567891011121314$ git diff index.htmldiff --git a/index.html b/index.htmlindex 5604b48..98782b0 100644--- a/index.html+++ b/index.html@@ -6,5 +6,6 @@ &lt;/head&gt; &lt;body&gt; &lt;div&gt;这是我开始学习git的第一天&lt;/div&gt;+ &lt;div这是我第一次在命令行修改文件&gt;&lt;/div&gt; &lt;/body&gt;-&lt;/html&gt;\\ No newline at end of file+&lt;/html&gt; 在左边是+的就是添加的，是-的就是删除的 现在我们再次用 git add 进行添加 12345678910$ git add index.html``` 提交完成之后用 git status 去查看一下```bash$ git statusOn branch masterChanges to be committed: (use \"git reset HEAD &lt;file&gt;...\" to unstage) modified: index.html 同样是没有输出，再次用 git commit -m去进行提交 123$ git commit -m '这次我添加了一个div'[master c1bf1c2] 这次我添加了一个div 1 file changed, 2 insertions(+), 1 deletion(-) 现在可以看到提交成功，再次用 git status 查看 123$ git statusOn branch masternothing to commit, working tree clean 这就是git中终端修改文件并再次提交的过程 git log 可以看到最近到最远的提交日志 123456789101112$ git logcommit c1bf1c20bd1c6e375fb4037aaf88116368da7e8f (HEAD -&gt; master)Author: OptimusPrime666 &lt;136977433@qq.com&gt;Date: Mon Mar 25 15:48:54 2019 +0800 这次我添加了一个divcommit 5fb4e8aaa8ad09111a6ada138535c46780847058Author: OptimusPrime666 &lt;136977433@qq.com&gt;Date: Mon Mar 25 14:01:06 2019 +0800 这是我的第一天学习git 可以看到我提交了两次。如果看起来太过冗余，可以加上 --pretty=oneline 123$ git log --pretty=onelinec1bf1c20bd1c6e375fb4037aaf88116368da7e8f (HEAD -&gt; master) 这次我添加了一个div5fb4e8aaa8ad09111a6ada138535c46780847058 这是我的第一天学习git 这样看起来就比较舒服了。现在我们看到有两个版本，我现在打算回退到第一个版本，使用 git reset --hard HEAD^ ，这里说一下，HEAD是当前版本，加一个 ^ 是回退到上一个版本，回退两个的话就加两个，如果想要回退的版本太多的话就写成 git reset --hard HEAD~100 这样也是可以的 12$ git reset --hard HEAD^HEAD is now at 5fb4e8a 这是我的第一天学习git 现在回退成功，可以用 cat index.html 查看是不是回退成功了 1234567891011$ cat index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;这是我开始学习git的第一天&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到 &lt;div&gt;这次我添加了一个div&lt;/div&gt; 这个已经没了，回退成功！！ 但是现在我有发现这个版本有问题，不想用了，我想回到我未来的那个版本，怎么办？知道没有吧命令行的窗口关掉，你就可以去上面看那个 git log --pretty=oneline 命令行输出的东西，有你的版本号，可以选取前面的几位数来进行回退，但是也别太少，那样容易找到多个版本以至于混淆。 12$ git reset --hard c1bf1c20HEAD is now at c1bf1c2 这次我添加了一个div 执行之后可以看看是否成功了 123456789101112$ cat index.html&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;这是我开始学习git的第一天&lt;/div&gt; &lt;div这是我第一次在命令行修改文件&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 可以看到回退成功，那个 &lt;div&gt;这是我第一次在命令行修改文件&lt;/div&gt;又回来了。 如果版本回退之后不小心把命令行关了也没事，因为让版本回到之前需要就是 commit id 可以用 git reflog 来查看你的每一条命令 12345$ git reflogc1bf1c2 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to c1bf1c205fb4e8a HEAD@&#123;1&#125;: reset: moving to HEAD^c1bf1c2 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 这次我添加了一个div5fb4e8a HEAD@&#123;3&#125;: commit (initial): 这是我的第一天学习git 这就是操作了多少次，可以利用 commit id 来进行版本的回到未来。 五、工作区和暂存区 工作区（Working Directory） 工作区就是电脑里面能看到的目录，比如我的index.html文件等等。 版本库（Repository） 工作区有一个隐藏着的文件夹 .git 这个就是版本库，如果不做这个文件夹的属性的话，它是看不到的。 把文件向版本库提交的时候有两步：1.使用 git add 把文件提交到暂存区。2.使用 git commit 把暂存区的内run提交到当前分支。 当我们创建git版本库的时候，git自动创建了一条分支master，git commit 就是提交到master分支上，可以理解为把修改完成并且需要提交的内容全部放在暂存区，然后一次性提交到版本库 咱们现在做一个实验，对文件进行第一次修改 -&gt; git add -&gt;对文件进行第二次修改 -&gt; git commit ，这样可以看出第一次修改之后胡放入暂存区，第二次修改并没有放入暂存区，所以 git commit 仅仅是对第一次的修改进行的提交 123456789101112131415161718192021222324GDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ vim index.htmlGDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ git add index.htmlGDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ vim index.htmlGDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ git commit -m '这是我第二天学习git'[master 555f4a9] 这是我第二天学习git 1 file changed, 2 insertions(+), 1 deletion(-)GDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\") 这样看就比较明显了，我再次 git status 的时候发现第二次修改并没有被提交，原因就是上面说的那些。 六、撤销修改 如果发现自己在提交过程中发现有错误，需要撤销，使用 git checkout – 文件名 可以撤销修改，这条指令有两个作用：一种是 index.html 自从修改之后没有被提交到暂存区，使用这条指令之后就回到和原来版本库一样。一种是已经添加到暂存区，而且有做了修改，使用这条命令就会让 index.html 回到添加到暂存区的状态 12345678910111213GDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ git statusOn branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: index.htmlno changes added to commit (use \"git add\" and/or \"git commit -a\")GDS@LAPTOP-QTJCSB7S MINGW64 ~/Desktop/git (master)$ git checkout -- index.html 这时候再去 git status 就会发现所做的修改消失了，内容还原了。","categories":[],"tags":[]},{"title":"语义化","slug":"语义化","date":"2019-03-20T09:04:37.000Z","updated":"2019-03-20T10:39:54.361Z","comments":true,"path":"2019/03/20/语义化/","link":"","permalink":"http://yoursite.com/2019/03/20/语义化/","excerpt":"","text":"理解HTML语义化1、什么是HTML语义化？ &lt;基本上都是围绕着几个主要的标签，像标题（H1~H6）、列表（li）、强调（strong em）等等&gt; 根据内容的结构化（内容语义化），选择合适的标签（代码语义化）便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。 2、为什么要语义化？ 为了在没有CSS的情况下，页面也能呈现出很好地内容结构、代码结构:为了裸奔时好看；用户体验：例如title、alt用于解释名词或解释图片信息、label标签的活用；有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。3、写HTML代码时应注意什么？ 尽可能少的使用无语义的标签div和span；在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；不要使用纯样式标签，如：b、font、u等，改用css设置。需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；表单域要用fieldset标签包起来，并用legend标签说明表单的用途；每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。 4、HTML5新增了header、footer、hgroup、nav、aside、section、article等标签","categories":[],"tags":[]},{"title":"slice","slug":"slice","date":"2019-03-19T11:55:23.000Z","updated":"2019-03-21T04:02:28.649Z","comments":true,"path":"2019/03/19/slice/","link":"","permalink":"http://yoursite.com/2019/03/19/slice/","excerpt":"数组方法slice的封装","text":"数组方法slice的封装 这种封装的还有会有不能正常判断的几种条件，欢迎修改123456789101112131415161718192021222324252627282930Array.prototype.mySlice = function(start,end)&#123; if(typeof start!== Number&amp;&amp;typeof end!== Number)&#123; return this; &#125; let newarr = []; if(arguments[0]&amp;&amp;!arguments[1]&amp;&amp;arguments[1]!==0)&#123; if(arguments[0]&gt;0)&#123; for (var i = start; i &lt; this.length; i++) &#123; newarr.myPush(this[i]) &#125; &#125;else if(arguments[0]&lt;0)&#123; for (var i = this.length+start; i &lt; this.length; i++) &#123; newarr.myPush(this[i]); &#125; &#125; &#125;else if(arguments[1])&#123; if(start&lt;0)&#123; return [] &#125;else if(end&lt;0)&#123; for (var i = start; i &lt; this.length+end; i++) &#123; newarr.myPush(this[i]) &#125; &#125;else&#123; for (var i = start; i &lt; end; i++) &#123; newarr.myPush(this[i]) &#125; &#125; &#125; return newarr; &#125;","categories":[],"tags":[]},{"title":"如何规避javaScript多人开发重名问题","slug":"如何规避javaScript多人开发重名问题","date":"2019-01-20T03:52:44.000Z","updated":"2019-03-30T09:53:31.689Z","comments":true,"path":"2019/01/20/如何规避javaScript多人开发重名问题/","link":"","permalink":"http://yoursite.com/2019/01/20/如何规避javaScript多人开发重名问题/","excerpt":"","text":"1.采用命名空间 2.采用封闭空间 3.js模块化mvc(数据层，视图层，控制层) 4.seajs 5.变量转换为对象的属性 6.对象化","categories":[],"tags":[]},{"title":"网页从输入网址到渲染完成的7步","slug":"网页从输入网址到渲染完成的7步","date":"2019-01-04T09:37:09.000Z","updated":"2019-03-30T09:42:54.617Z","comments":true,"path":"2019/01/04/网页从输入网址到渲染完成的7步/","link":"","permalink":"http://yoursite.com/2019/01/04/网页从输入网址到渲染完成的7步/","excerpt":"","text":"1.输入网址 2.发送DNS服务器，并获取域名对应的web服务器对应的ip 3.与web服务器建立TCP连接 4.浏览器向web服务器发送http请求 5.web服务器响应请求，并返回指定的url数据(或者错误信息) 6.浏览器下载web服务器返回的数据及解析html源文件 7.生成DOM树，解析css和js渲染页面，直至显示完成","categories":[],"tags":[]},{"title":"两种盒子模型","slug":"两种盒子模型","date":"2018-07-05T02:44:37.000Z","updated":"2019-03-27T12:35:28.797Z","comments":true,"path":"2018/07/05/两种盒子模型/","link":"","permalink":"http://yoursite.com/2018/07/05/两种盒子模型/","excerpt":"","text":"##两种盒子模型 盒子模型分为W3C盒子模型和IE盒子模型两种，这两种盒子模型有细微的差异，其中IE的盒子模型中内容(content)是内容(content)加上内边距(padding)以及边框(border)。 从下图可以清楚的看出 两种盒子模型","categories":[],"tags":[]},{"title":"ReactPrinciple","slug":"ReactPrinciple","date":"2018-06-13T07:23:14.000Z","updated":"2019-03-21T07:59:32.073Z","comments":true,"path":"2018/06/13/ReactPrinciple/","link":"","permalink":"http://yoursite.com/2018/06/13/ReactPrinciple/","excerpt":"","text":"##React的底层原理 React 核心技术 —— 虚拟DOM（Virtual DOM） 在前端开发的过程中，我们经常会做的一件事就是将变化的数据实时更新到UI上，这时就需要对DOM进行更新和重新渲染，而频繁的DOM操作通常是性能瓶颈产生的原因之一，有时候我们会遇到这样一种尴尬的情况：比如有一个列表数据，当用户执行刷新操作时，Ajax会重新从后台请求数据，即使新请求的数据和上次完全相同，DOM也会被全部更新一遍并进行重新渲染，这样就产生了不必要的性能开销。 React为此引入了虚拟DOM（Virtual DOM）机制：对于每一个组件，React会在内存中构建一个相对应的DOM树，基于React开发时所有的DOM构造都是通过虚拟DOM进行，每当组件的状态发生变化时，React都会重新构建整个DOM数据，然后将当前的整个DOM树和上一次的DOM树进行对比，得出DOM结构变化的部分(Patchs)，然后将这些Patchs 再更新到真实DOM中。整个过程都是在内存中进行，因此是非常高效的。借用一张图可以清晰的表示虚拟DOM的工作机制： React1","categories":[],"tags":[]},{"title":"清除浮动","slug":"清除浮动","date":"2018-04-05T02:25:35.000Z","updated":"2019-03-21T07:59:34.226Z","comments":true,"path":"2018/04/05/清除浮动/","link":"","permalink":"http://yoursite.com/2018/04/05/清除浮动/","excerpt":"","text":"##自己总结的清除浮动的几种方式 1.父级div定义伪类：after和zoom 123456789101112131415161718&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat:after&#123;display:block;clear:both;content:\"\";visibility:hidden;height:0&#125; .clearfloat&#123;zoom:1&#125; &lt;/style&gt; &lt;div class=\"div1 clearfloat\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题 优点：浏览器支持好，不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等） 缺点：代码多，不少初学者不理解原理，要两句代码结合使用，才能让主流浏览器都支持 建议：推荐使用，建议定义公共类，以减少CSS代码 2.在结尾处添加空div标签clear:both 123456789101112131415161718&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; /*清除浮动代码*/ .clearfloat&#123;clear:both&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;div class=\"clearfloat\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度 优点：简单，代码少，浏览器支持好，不容易出现怪问题 缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不爽 建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法 3.父级div定义height 1234567891011121314&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/height:200px;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题 优点：简单，代码少，容易掌握 缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题 建议：不推荐使用，只建议高度固定的布局时使用 4.父级div定义overflow:hidden 1234567891011121314&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/width:98%;overflow:hidden&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px;width:98%&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度 优点：简单，代码少，浏览器支持好 缺点：不能和position配合使用，因为超出的尺寸的会被隐藏 建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用 5.父级div定义overflow:auto 1234567891011121314&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/width:98%;overflow:auto&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;margin-top:10px;width:98%&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度 优点：简单，代码少，浏览器支持好 缺点：内部宽高超过父级div时，会出现滚动条。 建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。 6.父级div也一起浮动 1234567891011121314&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/width:98%;margin-bottom:10px;float:left&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;width:98%;/*解决代码*/clear:both&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：所有代码一起浮动，就变成了一个整体 优点：没有优点 缺点：会产生新的浮动问题。 建议：不推荐使用，只作了解。 7.父级div定义display:table 1234567891011121314&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;/*解决代码*/width:98%;display:table;margin-bottom:10px;&#125; .div2&#123;background:#800080;border:1px solid red;height:100px;width:98%;&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：将div属性变成表格 优点：没有优点 缺点：会产生新的未知问题 建议：不推荐使用，只作了解 8.结尾处加br标签clear:both 1234567891011121314151617&lt;style type=\"text/css\"&gt; .div1&#123;background:#000080;border:1px solid red;margin-bottom:10px;zoom:1&#125; .div2&#123;background:#800080;border:1px solid red;height:100px&#125; .left&#123;float:left;width:20%;height:200px;background:#DDD&#125; .right&#123;float:right;width:30%;height:80px;background:#DDD&#125; .clearfloat&#123;clear:both&#125; &lt;/style&gt; &lt;div class=\"div1\"&gt; &lt;div class=\"left\"&gt;Left&lt;/div&gt; &lt;div class=\"right\"&gt;Right&lt;/div&gt;&lt;br class=\"clearfloat\" /&gt;&lt;/div&gt;&lt;div class=\"div2\"&gt; div2&lt;/div&gt; 原理：父级div定义zoom:1来解决IE浮动问题，结尾处加br标签clear:both 建议：不推荐使用，只作了解","categories":[],"tags":[]},{"title":"MVVM和MVC的区别","slug":"MVVM和MVC的区别","date":"2018-03-30T12:19:36.000Z","updated":"2019-03-31T13:04:15.148Z","comments":true,"path":"2018/03/30/MVVM和MVC的区别/","link":"","permalink":"http://yoursite.com/2018/03/30/MVVM和MVC的区别/","excerpt":"","text":"##MVC设计模式(model和view之间不能通信) mvc是一种设计模式，M表示Model，V表示View，C表示Controller 1.Model负责存储、定义和操作数据 2.View用来展示给用户，并且和用户进行交互 3.Controller是Model和View的协调者，Controller把model拿到View，Controller可以和View和model进行通信，View不能和Controller通信，当数据更新时Model和Controller通信，Controller在通知View进行变化 4.View仅仅是用来展示的，Model仅仅是用来存放数据的 ##MVVM是一种设计思想 MVVM中M代表的是Model，V代表的是View，VM代表的是ViewModel，在这种思想中Model和ViewModel的交互是双向的，Model改变的时候ViewModel也会改变，进而ViewModel的变化也会立刻映射到View上。","categories":[],"tags":[]},{"title":"Vue中双向绑定的的原理","slug":"Vue中双向绑定的的原理","date":"2018-03-21T12:49:44.000Z","updated":"2019-03-31T13:03:06.389Z","comments":true,"path":"2018/03/21/Vue中双向绑定的的原理/","link":"","permalink":"http://yoursite.com/2018/03/21/Vue中双向绑定的的原理/","excerpt":"","text":"Vue中的双向绑定的实现是结合了数据劫持和订阅者-发布者模式，遍历data里的所有属性，并转为setter和getter，在属性被变化时通知变化。这里还会整合Observer、Compile、Watcher三者，通过Observer监听自己model的数据变化，通过Compile里解析编译模板的指令，最后用Watcher搭建起来Observer和Compile之间的通信桥梁，达到数据操控视图","categories":[],"tags":[]},{"title":"VuePrinciple","slug":"VuePrinciple","date":"2018-03-20T02:37:52.000Z","updated":"2019-03-30T09:40:46.936Z","comments":true,"path":"2018/03/20/VuePrinciple/","link":"","permalink":"http://yoursite.com/2018/03/20/VuePrinciple/","excerpt":"##Vue的底层原理","text":"##Vue的底层原理VUE实现数据双向绑定的效果，需要三大模块1、Observer：能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者 2、Compile：对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数 3、Watcher：作为链接Observer和Compile的桥梁，能够订阅并受到每个属性变动的通知，并执行指令绑定的相应回掉函数，从而更新视图 未完待续…","categories":[],"tags":[]},{"title":"Vue生命周期","slug":"Vue生命周期","date":"2018-03-15T08:17:04.000Z","updated":"2019-03-30T09:18:27.888Z","comments":true,"path":"2018/03/15/Vue生命周期/","link":"","permalink":"http://yoursite.com/2018/03/15/Vue生命周期/","excerpt":"","text":"##Vue生命周期 1.beforeCreate 组件创建前 没有$el、$data、以及data里面的属性 2.created 组件创建后 没有$el，$data以及data里面的属性被初始化， 3.beforeMount 组件挂载前 $el、$data以及data里面的值被初始化 4.Mounted 组件挂载后 $el、$data以及data里面的值被初始化，通常都是在这个钩子函数中请求后台数据(非事件调用) 5.beforeUpdate 组件更新前 在这一步，页面中显示的数据是之前的，但是data里面的数据是最新的 6.update 组件更新后 这一步中，页面已经和data里面的数据同步了 7.beforeDestroy 组件销毁前 在这一步，实例还可以被调用 8.destroyed 组件销毁后 这一步Vue实例指示的东西完全解绑，所有的事件监听也完全被移除，所有的子实例也会被销毁 在created和beforeMount这两个生命周期中间会判断有没有$el对象，如果有就向下执行，没有的话就停止执行，直到调用vm.$mount(el) beforeUptate执行完成之后会在内存中重新渲染一个最新的DOM树，再重新渲染到页面当中，这一步就完成了从data层到view层的更新","categories":[],"tags":[]},{"title":"Ajax优缺点","slug":"Ajax优缺点","date":"2018-01-15T13:08:22.000Z","updated":"2019-03-27T12:35:40.534Z","comments":true,"path":"2018/01/15/Ajax优缺点/","link":"","permalink":"http://yoursite.com/2018/01/15/Ajax优缺点/","excerpt":"","text":"Ajax优缺点Ajax工作原理： 相当于在客户端与服务端之间加了一个抽象层(Ajax引擎)，使用户请求和服务器响应异步化，并不是所有的请求都提交给服务器，像一些数据验证和数据处理 都交给Ajax引擎来完成，只有确认需要向服务器读取新数据时才右Ajax引擎向服务器提交请求。 Ajax优缺点： 优点： 1.无刷新更新数据 Ajax最大的优点就是能在不刷新整个页面的情况下维持与服务器通信 2.异步与服务器通信 使用异步的方式与服务器通信，不打断用户的操作 3.前端与后端负载均衡 将一些后端的工作移到前端，减少服务器与带宽的负担 4.基于规范被广泛支持 不需要下载浏览器插件或者小程序，但需要客户允许JavaScript在浏览器上执行。 5.界面与应用分离 Ajax使得界面与应用分离，也就是数据与呈现分离。 缺点： 1.Ajax干掉了Back与History功能，即对浏览器机制的破坏 在动态更新页面的情况下，用户无法回到前一页的页面状态，因为浏览器仅能记忆历史纪录中的静态页面 2.安全问题 AJAX技术给用户带来很好的用户体验的同时也对IT企业带来了新的安全威胁，Ajax技术就如同对企业数据建立了一个直接通道。这使得开发者在不经意间会暴露比以前更多的数据和服务器逻辑。 3.对搜索引擎支持较弱 4.破坏程序的异常处理机制 5.违背URL与资源定位的初衷 6.不能很好地支持移动设备 7.客户端肥大，太多客户段代码造成开发上的成本","categories":[],"tags":[]}]}